/*! \mainpage Easy Archive Manager
 *
 * \section intro_sec Introduction
 *
 * EAMAN (Easy Archive Manager) is a front-end to various command line archiving tools for Linux operating system.
 * It uses the GTK+2 and Hildon toolkits to provide the program interface; therefore it is capable of running on any system where GTK+2 and Hildon support exists. A large number of other applications also use the toolkit, so support is widespread among other Linux distributions irrespective of their specific desktop solution.
 * Supported formats with an appropriate installed program are 7zip,, bzip2, gzip, rar, RPM, DEB, tar, and zip.
 *
 * More informations at home page: https://garage.maemo.org/projects/eaman
 * 
 *
 */


/**
 * @file
 * @author  Tomasz Pieniążek <t.pieniazek@gazeta.pl>
 *
 * @section LICENSE
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Library General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *
 * @section DESCRIPTION
 *
 * Support for DEB packages.
 */

#include "deb.h"
#include "utils.h"

/**
 * Function used to opening deb packages
 *
 * @param archive Archive we want to open
 *
 */
void OpenDeb(AM_Archive *archive)
{
	gchar *command = NULL;
	gchar *archive_no_path = NULL;
	gboolean result;

	archive_no_path = g_strrstr (archive->escaped_path,"/");
	archive_no_path++;
#ifdef GNM_NUSE_TMP
	archive->tmp = g_strconcat (g_strconcat(" ", whereToExtract, "/", NULL),archive_no_path,NULL);
#else
	archive->tmp = g_strconcat (" /tmp/",archive_no_path,NULL);
#endif

	command = g_strconcat ("cp ",archive->escaped_path,archive->tmp,NULL);
	result = am_a_run_command ( command , 0);
	g_free (command);
	if (result == FALSE)
		return;

#ifdef GNM_NUSE_TMP
	chdir (whereToExtract);
#else
	chdir ("/tmp");
#endif
	command = g_strconcat ("ar xv" , archive->tmp, NULL);
	result = am_a_run_command ( command , 0);
	g_free (command);
	g_free (archive->tmp);

#ifdef GNM_NUSE_TMP
	archive->tmp = g_strdup (g_strconcat(whereToExtract, "/data.tar.gz", NULL));

	unlink (g_strconcat(whereToExtract, "/control.tar.gz", NULL));
	unlink (g_strconcat(whereToExtract, "/debian-binary", NULL));
#else
	archive->tmp = g_strdup ("/tmp/data.tar.gz");

	unlink ("/tmp/control.tar.gz");
	unlink ("/tmp/debian-binary");
#endif
	unlink (archive_no_path);

	if (result == FALSE)
		return;

#ifdef GNM_NUSE_TMP
	command = g_strconcat (g_strconcat("tar tfzv ",whereToExtract, "/data.tar.gz", NULL), NULL);
#else
	command = g_strconcat ("tar tfzv /tmp/data.tar.gz", NULL);
#endif
	archive->dummy_size = 0;
	archive->nr_of_files = 0;
	archive->nr_of_dirs = 0;
	archive->format ="DEB";
	archive->parse_output = TarOpen;
	SpawnAsyncProcess ( archive , command , 0, 0);
	g_free (command);

	if (archive->child_pid == 0)
		return;

	char *names[]= {("Filename"),("Permissions"),("Symbolic Link"),("Owner/Group"),("Size"),("Date"),("Time")};
	GType types[]= {G_TYPE_STRING,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_UINT64,G_TYPE_STRING,G_TYPE_STRING};
	am_a_create_liststore ( 7, names , (GType *)types, archive );
}
